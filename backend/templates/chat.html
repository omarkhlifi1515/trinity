{% extends "layout.html" %}

{% block title %}Live Chat Feed{% endblock %}
{% block theme_class %}user-theme{% endblock %}

{% block sidebar %}
<div class="sidebar-header">
    <h4 class="mb-0 text-white"><i class="fa-solid fa-shield-halved text-primary"></i> TrinitySim</h4>
</div>
<nav class="nav flex-column">
    <a class="nav-link user-dashboard-link" href="{{ url_for('dashboard_user') }}"><i class="fa fa-home me-2"></i> Overview</a>
    <a class="nav-link user-dashboard-link" href="{{ url_for('tasks') }}"><i class="fa fa-tasks me-2"></i> My Tasks</a>
    <a class="nav-link user-dashboard-link active" href="{{ url_for('chat') }}"><i class="fa fa-comments me-2"></i> Chat</a>
    <a class="nav-link user-dashboard-link" href="{{ url_for('documents') }}"><i class="fa fa-folder-open me-2"></i> Documents</a>
    <a class="nav-link text-danger mt-auto" href="{{ url_for('logout') }}"><i class="fa fa-sign-out me-2"></i> Logout</a>
</nav>
{% endblock %}

{% block content %}
<div class="card h-100 chat-container">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="card-title mb-0"><i class="fa fa-comments me-2"></i> Live Chat Feed</h5>
        <div class="d-flex align-items-center">
            <span class="badge bg-success me-2" id="connection-status">
                <i class="fa fa-circle"></i> Connected
            </span>
            <span class="badge bg-secondary" id="online-count">
                <i class="fa fa-users"></i> <span id="user-count">0</span> online
            </span>
        </div>
    </div>
    <div class="card-body d-flex flex-column p-0">
        <div class="chat-box" id="chat-box">
            <div class="text-center text-muted py-5" id="loading-indicator">
                <div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div>
                Loading messages...
            </div>
        </div>
        <div class="chat-input-container p-3 border-top">
            <form id="message-form" method="POST" action="{{ url_for('chat') }}">
                {{ form.hidden_tag() }}
                <div class="input-group">
                    <button type="button" class="btn btn-outline-secondary" id="emoji-btn" title="Add emoji">
                        <i class="fa fa-smile"></i>
                    </button>
                    {{ form.message(id="message_input", class="form-control", placeholder="Type a message...", rows="1", autocomplete="off", maxlength="500") }}
                    <button type="submit" class="btn btn-primary" id="send-btn" disabled>
                        <i class="fa fa-paper-plane"></i> Send
                    </button>
                </div>
                <div class="d-flex justify-content-between align-items-center mt-2">
                    <small class="text-muted">
                        <span id="char-count">0</span>/500 characters
                    </small>
                    <small class="text-muted" id="typing-indicator"></small>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Toast Notification Container -->
<div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 1050;">
    <div id="toast-container"></div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const chatBox = document.getElementById('chat-box');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message_input');
        const sendBtn = document.getElementById('send-btn');
        const charCount = document.getElementById('char-count');
        const typingIndicator = document.getElementById('typing-indicator');
        const connectionStatus = document.getElementById('connection-status');
        const loadingIndicator = document.getElementById('loading-indicator');
        const currentUserId = "{{ current_user.id }}";
        const currentUsername = "{{ current_user.username if current_user.username else current_user.id }}";
        
        // Helper to check if message is from current user
        function isCurrentUser(message) {
            return message.user === currentUsername || 
                   message.user === currentUserId ||
                   (message.user_id && message.user_id == currentUserId);
        }
        
        let currentMessagesCount = 0;
        let isConnected = true;
        let pollInterval = null;
        let typingTimeout = null;
        let lastMessageId = null;

        // Auto-resize textarea
        const adjustTextareaHeight = () => {
            messageInput.style.height = 'auto';
            messageInput.style.height = Math.min(messageInput.scrollHeight, 150) + 'px';
        };

        messageInput.addEventListener('input', () => {
            adjustTextareaHeight();
            const length = messageInput.value.trim().length;
            charCount.textContent = length;
            sendBtn.disabled = length === 0;
            
            // Typing indicator
            clearTimeout(typingTimeout);
            if (length > 0) {
                // In a real app, you'd send typing events to server
            }
            typingTimeout = setTimeout(() => {
                typingIndicator.textContent = '';
            }, 1000);
        });

        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!sendBtn.disabled) {
                    messageForm.dispatchEvent(new Event('submit'));
                }
            }
        });

        adjustTextareaHeight();

        // Show toast notification
        function showToast(message, type = 'info') {
            const toastId = 'toast-' + Date.now();
            const toast = document.createElement('div');
            toast.className = `toast align-items-center text-white bg-${type} border-0`;
            toast.setAttribute('role', 'alert');
            toast.id = toastId;
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            `;
            document.getElementById('toast-container').appendChild(toast);
            const bsToast = new bootstrap.Toast(toast, { delay: 3000 });
            bsToast.show();
            toast.addEventListener('hidden.bs.toast', () => toast.remove());
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diff = now - date;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            if (seconds < 60) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        // Render messages
        function renderMessages(allMessages) {
            if (loadingIndicator && loadingIndicator.parentNode) {
                loadingIndicator.remove();
            }

            if (!allMessages || allMessages.length === 0) {
                if (chatBox.querySelector('.text-center.text-muted') === null) {
                    chatBox.innerHTML = '<div class="text-center text-muted py-5"><i class="fa fa-comments fa-3x mb-3 opacity-50"></i><p>No messages yet. Start the conversation!</p></div>';
                }
                currentMessagesCount = 0;
                return;
            }

            // Remove empty state
            const emptyState = chatBox.querySelector('.text-center.text-muted');
            if (emptyState && emptyState.querySelector('.fa-comments')) {
                emptyState.remove();
            }

            const isScrolledToBottom = chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight < 100;

            // Track which messages we've already rendered
            const existingMessageIds = new Set();
            chatBox.querySelectorAll('.chat-message').forEach(msg => {
                const msgId = msg.getAttribute('data-message-id');
                if (msgId) existingMessageIds.add(msgId);
            });

            // Render new messages
            allMessages.forEach((message, index) => {
                const messageId = message.id || `${message.user}-${message.timestamp}-${index}`;
                if (existingMessageIds.has(messageId)) return;

                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message', 'd-flex', 'mb-3', 'fade-in');
                messageElement.setAttribute('data-message-id', messageId);

                const isCurrentUser = message.user === currentUsername || 
                                      message.user === currentUserId ||
                                      (message.user_id && message.user_id == currentUserId);
                if (isCurrentUser) {
                    messageElement.classList.add('justify-content-end');
                }

                const messageContent = document.createElement('div');
                messageContent.classList.add('message-content', 'p-3', 'rounded-3', 'shadow-sm', 'position-relative');

                if (isCurrentUser) {
                    messageContent.classList.add('bg-primary', 'text-white', 'mine');
                } else {
                    messageContent.classList.add('bg-dark', 'text-white', 'other', 'border', 'border-secondary');
                    const userSpan = document.createElement('div');
                    userSpan.classList.add('message-user', 'fw-bold', 'mb-1', 'small');
                    userSpan.textContent = message.user || 'Unknown';
                    messageContent.appendChild(userSpan);
                }
                
                const textElement = document.createElement('div');
                textElement.classList.add('message-text');
                textElement.textContent = message.text;
                messageContent.appendChild(textElement);

                const timestampElement = document.createElement('div');
                timestampElement.classList.add('message-timestamp', 'mt-1', 'small', 'opacity-75');
                timestampElement.textContent = formatTimestamp(message.timestamp);
                messageContent.appendChild(timestampElement);

                messageElement.appendChild(messageContent);
                chatBox.appendChild(messageElement);
            });

            // Scroll to bottom if user was at bottom
            if (isScrolledToBottom) {
                setTimeout(() => {
                    chatBox.scrollTop = chatBox.scrollHeight;
                }, 100);
            }

            currentMessagesCount = allMessages.length;
        }

        // Fetch messages with error handling
        async function fetchMessages() {
            try {
                const response = await fetch('{{ url_for("api_messages") }}', {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const messages = await response.json();
                renderMessages(messages);
                
                if (!isConnected) {
                    isConnected = true;
                    connectionStatus.innerHTML = '<i class="fa fa-circle"></i> Connected';
                    connectionStatus.className = 'badge bg-success me-2';
                }
            } catch (error) {
                console.error('Error fetching messages:', error);
                if (isConnected) {
                    isConnected = false;
                    connectionStatus.innerHTML = '<i class="fa fa-circle"></i> Reconnecting...';
                    connectionStatus.className = 'badge bg-warning me-2';
                    showToast('Connection lost. Attempting to reconnect...', 'warning');
                }
            }
        }

        // Handle form submission
        messageForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const messageText = messageInput.value.trim();
            if (messageText === '') {
                return;
            }

            // Disable input while sending
            messageInput.disabled = true;
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

            const formData = new FormData(messageForm);

            try {
                const response = await fetch("{{ url_for('chat') }}", {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.status === 'success') {
                    messageInput.value = '';
                    charCount.textContent = '0';
                    adjustTextareaHeight();
                    messageInput.focus();
                    
                    // Immediately fetch new messages
                    await fetchMessages();
                } else {
                    showToast('Failed to send message. Please try again.', 'danger');
                    messageInput.disabled = false;
                    sendBtn.disabled = false;
                    sendBtn.innerHTML = '<i class="fa fa-paper-plane"></i> Send';
                }
            } catch (error) {
                console.error('Error sending message:', error);
                showToast('An error occurred. Please check your connection.', 'danger');
                messageInput.disabled = false;
                sendBtn.disabled = false;
                sendBtn.innerHTML = '<i class="fa fa-paper-plane"></i> Send';
            }
        });

        // Start polling
        fetchMessages();
        pollInterval = setInterval(fetchMessages, 2000);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (pollInterval) clearInterval(pollInterval);
        });

        // Keep input focused
        messageInput.focus();
    });
</script>
{% endblock %}