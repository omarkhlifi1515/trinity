{% extends "layout.html" %}

{% block title %}Live Chat Feed{% endblock %}
{% block theme_class %}user-theme{% endblock %}

{% block sidebar %}
<div class="sidebar-header">
    <h4 class="mb-0 text-white"><i class="fa-solid fa-shield-halved text-primary"></i> TrinitySim</h4>
</div>
<nav class="nav flex-column">
    <a class="nav-link user-dashboard-link" href="{{ url_for('dashboard_user') }}"><i class="fa fa-home me-2"></i> Overview</a>
    <a class="nav-link user-dashboard-link" href="{{ url_for('tasks') }}"><i class="fa fa-tasks me-2"></i> My Tasks</a>
    <a class="nav-link user-dashboard-link active" href="{{ url_for('chat') }}"><i class="fa fa-comments me-2"></i> Chat</a>
    <a class="nav-link user-dashboard-link" href="{{ url_for('documents') }}"><i class="fa fa-folder-open me-2"></i> Documents</a>
    <a class="nav-link text-danger mt-auto" href="{{ url_for('logout') }}"><i class="fa fa-sign-out me-2"></i> Logout</a>
</nav>
{% endblock %}

{% block content %}
<div class="card h-100">
    <div class="card-header">
        <h5 class="card-title mb-0"><i class="fa fa-satellite-dish me-2"></i> Live Chat Feed</h5>
    </div>
    <div class="card-body d-flex flex-column">
        <div class="chat-box mb-3 flex-grow-1" id="chat-box">
            <!-- Messages will be loaded here by JavaScript -->
        </div>
        <form id="message-form" method="POST" action="{{ url_for('chat') }}">
            {{ form.hidden_tag() }}
            <div class="input-group">
                {{ form.message(id="message_input", class="form-control", placeholder="Type a message...", rows="1", autocomplete="off") }}
                {{ form.submit(class="btn btn-primary") }}
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const chatBox = document.getElementById('chat-box');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message_input');
        const currentUserId = "{{ current_user.id }}"; // Get current user ID from Flask
        let currentMessagesCount = 0;

        // Auto-resize textarea
        const adjustTextareaHeight = () => {
            messageInput.style.height = 'auto'; // Reset height
            messageInput.style.height = (messageInput.scrollHeight > 150 ? 150 : messageInput.scrollHeight) + 'px'; // Set to scrollHeight, max 150px
        };

        messageInput.addEventListener('input', adjustTextareaHeight);
        // Also adjust on load in case there's pre-filled content (though it shouldn't be for chat)
        adjustTextareaHeight(); 

        // Function to render messages
        function renderMessages(allMessages) {
            // Take only the last 10 (or desired number) messages for display
            const messagesToDisplay = allMessages.slice(-10); 
            const newMessagesCount = messagesToDisplay.length;

            const initialScrollHeight = chatBox.scrollHeight;
            // Check if almost at bottom, or if chatBox is empty (initial load)
            const isScrolledToBottom = chatBox.scrollTop + chatBox.clientHeight >= initialScrollHeight - 5 || chatBox.childElementCount === 0;

            // Determine how many messages are actually new to display
            const currentlyDisplayedMessages = chatBox.querySelectorAll('.chat-message').length;
            
            // If the number of messages to display changes significantly (e.g., history trimmed, or going from empty to messages)
            // or if we have fewer messages to display than currently rendered, clear and re-render.
            if (newMessagesCount < currentlyDisplayedMessages || (newMessagesCount > 0 && currentlyDisplayedMessages === 0) || (newMessagesCount === 0 && currentlyDisplayedMessages > 0)) {
                chatBox.innerHTML = ''; // Clear everything
                currentMessagesCount = 0; // Reset internal counter
            }

            if (newMessagesCount === 0) {
                if (chatBox.innerHTML === '') {
                    chatBox.innerHTML = '<div class="text-center text-muted py-3">No messages yet.</div>';
                }
                currentMessagesCount = 0;
                return;
            }

            // Remove "No messages yet" placeholder if messages are incoming
            if (chatBox.childElementCount === 1 && chatBox.firstChild.classList.contains('text-center') && newMessagesCount > 0) {
                chatBox.innerHTML = '';
            }

            // Append only truly new messages based on their index in the `messagesToDisplay` array
            for (let i = currentMessagesCount; i < newMessagesCount; i++) {
                const message = messagesToDisplay[i];
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message', 'd-flex', 'mb-2', 'fade-in');

                const isCurrentUser = message.user === currentUserId;
                if (isCurrentUser) {
                    messageElement.classList.add('justify-content-end');
                }

                const messageContent = document.createElement('div');
                messageContent.classList.add('message-content', 'p-2', 'rounded', 'shadow-sm');

                if (isCurrentUser) {
                    messageContent.classList.add('bg-primary', 'text-white', 'mine');
                } else {
                    messageContent.classList.add('bg-light', 'text-dark', 'other');
                    const userSpan = document.createElement('small');
                    userSpan.classList.add('message-user', 'fw-bold', 'd-block');
                    userSpan.textContent = message.user;
                    messageContent.appendChild(userSpan);
                }
                
                const textElement = document.createElement('span');
                textElement.classList.add('message-text');
                textElement.textContent = message.text;

                const timestampElement = document.createElement('small');
                timestampElement.classList.add('message-timestamp', 'd-block', 'text-end', 'mt-1');
                timestampElement.textContent = message.timestamp;
                if (isCurrentUser) {
                    timestampElement.classList.add('text-white-50');
                } else {
                    timestampElement.classList.add('text-muted');
                }

                messageContent.appendChild(textElement);
                messageContent.appendChild(timestampElement);
                messageElement.appendChild(messageContent);
                chatBox.appendChild(messageElement);
            }

            // Scroll to bottom if new messages were added and user was at the bottom
            if (newMessagesCount > currentMessagesCount && isScrolledToBottom) {
                chatBox.scrollTop = chatBox.scrollHeight;
            }
            currentMessagesCount = newMessagesCount;
        }

        // Function to fetch messages from the API
        async function fetchMessages() {
            try {
                const response = await fetch('/api/messages');
                const messages = await response.json();
                renderMessages(messages);
            } catch (error) {
                console.error('Error fetching messages:', error);
            }
        }

        // Function to handle form submission
        messageForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const formData = new FormData(messageForm);
            if (messageInput.value.trim() === '') {
                return;
            }
            // Clear the input field immediately after sending
            messageInput.value = '';
            adjustTextareaHeight(); // Adjust height after clearing
            messageInput.focus(); // Focus the input field

            try {
                const response = await fetch("{{ url_for('chat') }}", {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();

                if (result.status === 'success') {
                    await fetchMessages(); // Immediately fetch new messages
                } else {
                    console.error('Error sending message:', result);
                    alert('Failed to send message.'); // Basic error feedback
                }
            } catch (error) {
                console.error('Error sending message:', error);
                alert('An error occurred while sending the message.'); // Basic error feedback
            }
        });

        // Initial fetch and start polling
        fetchMessages();
        setInterval(fetchMessages, 2000); // Poll every 2 seconds
    });
</script>
{% endblock %}